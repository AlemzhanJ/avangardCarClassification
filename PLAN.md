
# Вертикали

* **Вертикаль A — Cleanliness (Clean vs Dirty)**: модель + TS-инференс + React-карточка + калибровка «степени грязи».
* **Вертикаль B — Integrity (Damaged vs Undamaged)**: модель + TS-инференс + React-карточка + калибровка «степени повреждений».
* (Опц.) **Бонус**: YOLOv8n/Grad-CAM для подсветки дефектов — берёт тот, у кого остаётся время.

# Общие контракты (чтобы всё совместилось)

* Вход: `3×384×384`, нормализация ImageNet (mean \[0.485,0.456,0.406], std \[0.229,0.224,0.225]).
* Выход ONNX: **один логит** (форма `[1,1]`), имя выхода `logits`.
* Экспорт: `public/models/clean.onnx`, `public/models/damage.onnx`.
* Калибровка степеней: `public/config/severity.json`

  ```json
  { "dirty": {"thresholds":[0.33,0.66],"temperature":1.0},
    "damage":{"thresholds":[0.33,0.66],"temperature":1.0} }
  ```
* UI-карточка: принимает `label`, `prob` (0–1), `severity` (Low/Medium/High + %).
* Этика: блюрим номера в канвасе **до** инференса (общий компонент `ImageCanvas`).


# Таймлайн 36 ч (Asia/Almaty)

## 0–2 ч — старт и каркас

**Оба**

* Поднять Vite React + TS, добавить `onnxruntime-web`.
* Создать общий `ImageCanvas` с инструментом blur.
* Договориться о контрактах (см. выше), завести `infer.ts` с общей функцией пре-процессинга.

## 2–8 ч — данные и первые бейзлайны

**A (Cleanliness)**

* Сбор/чистка `clean/dirty` (≈200–300/класс минимум).
* Сплит 70/15/15, аугментации (brightness/contrast, hue, blur, rain/fog умеренно).

**B (Integrity)**

* Сбор/чистка `damaged/undamaged` (царапины/вмятины/ржавчина → damaged).
* Сплит и аугментации те же (без «грязевых» специфических).

**Оба**

* Быстрый zero-shot CLIP на валидации как baseline (5–10 мин).

## 8–14 ч — обучение v1

**A**

* EfficientNet-B0/MobileNetV3-L, AdamW, lr 3e-4, wd 1e-4, 6–8 эпох.
* Сохранить `best_clean.pt`, экспорт `clean.onnx`.

**B**

* Аналогично для damage → `best_damage.pt`, `damage.onnx`.

**Оба**

* Скрипт `eval.py`: F1/Precision/Recall/ROC-AUC, Confusion Matrix, сохранение графиков в `/reports`.

## 14–18 ч — фронт-интеграция v1

**A**

* Подключить `clean.onnx` в `infer.ts`, карточка **Cleanliness** в `App.tsx`.

**B**

* Подключить `damage.onnx`, карточка **Integrity**.

**Оба**

* Кнопка «Скрыть номера», проверка оффлайн-инференса на 5–10 фото.

## 18–22 ч — «степени» (без переобучения)

**Оба**

* Посчитать квантили вероятностей на валидации → заполнить `severity.json`.
* В `App.tsx` отобразить: `Low/Medium/High (NN%)` для обеих карточек.
* Подбор порога 0.5→0.6, если важнее точность (снизить FP для safety).

## 22–28 ч — улучшение качества

**A**

* Быстрая до-подготовка данных (баланс, лёгкая очистка), доп. 2–3 эпохи fine-tune.

**B**

* То же по своей вертикали.
* Если есть время: Grad-CAM для damage (теплограмма) **или** YOLOv8n на 1–3 эпохи.

## 28–34 ч — упаковка и визуал

**Оба**

* Обновить метрики, сделать 4–6 примеров FP/FN (почему ошиблись, как поправим).
* Скринкаст демо (30–60 сек), скрины UI.
* README: быстрый старт, этика, метрики, ограничения, «что дальше».

## 34–36 ч — репетиция и финал

**Оба**

* Прогон демо на свежих фото, тайминг питча 3–5 мин, роли в презентации:

  * A: данные → Cleanliness модель → метрики → severity.
  * B: данные → Integrity модель → метрики → (опц.) подсветка → финальный UX.

# Зоны совместной ответственности (чтобы оба трогали и модели, и фронт)

* **Код-ревью крест-накрест**: A ревьюит `train_damage.py` и PR с фронтом B; B — `train_clean.py` и фронт A.
* **Единый `infer.ts`**: общий препроцесс/постпроцесс, чтобы вы оба работали в TS.
* **Общие аугментации** в `common/augs.py`, чтобы сравнимо обучались.
* **Общая калибровка**: `severity.json` ведёте вместе.

# Чек-лист PR (коротко)

* Модель даёт логит `[1,1]`, проверен ONNXRuntime (CPU) локально.
* Время инференса на 384×384 в браузере ≤ 1–2 с.
* Добавлены метрики и 2 изображения (TP/FN) в `/reports`.
* Обновлён README.

# Риски и падения в «план Б»

* Мало данных → агрессивнее аугментации + class weights.
* Медленный инференс → IMG\_SIZE 320, MobileNetV3, вырубить лишние эффекты.
* YOLO не успевает → оставляем только бинарные модели + теплокарта.
* Плохой дисбаланс → калибруем порог под Precision (0.6–0.7).

